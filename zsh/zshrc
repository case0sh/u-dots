# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

setopt +o nomatch

bindkey -e
# bindkey '^R'      history-incremental-search-backward
bindkey "^[[5~"   up-line-or-history
bindkey "^[[6~"   down-line-or-history
bindkey "^[OH"    beginning-of-line
bindkey "^[[H"    beginning-of-line
bindkey "^[OF"    end-of-line
bindkey "^[[F"    end-of-line
bindkey '^[[1;3C' forward-word
bindkey '^[[C'    forward-word
bindkey '^[[1;3D' backward-word
bindkey '^[[D'    backward-word
bindkey '^[[C'    forward-char
bindkey '^[[D'    backward-char
bindkey '^?'      backward-delete-char
bindkey "^[[3~"   delete-char
bindkey "^[3;5~"  delete-char
bindkey '^[[3;5~' delete-word
bindkey '^H'      backward-delete-word
# space during searches
bindkey -M isearch " " magic-space

# edit the current command line in $EDITOR
autoload -U edit-command-line
zle -N edit-command-line
bindkey '^X^E' edit-command-line
# bindkey -M menuselect " " accept-and-menu-complete

autoload -U url-quote-magic
zle -N self-insert url-quote-magic

# foreground jobs
function foreground-current-job() {
  fg
}

zle -N foreground-current-job
bindkey -M emacs '^z' foreground-current-job

# global aliases
autoload -Uz compinit 
compinit -i

globalias() {
  if [[ $LBUFFER =~ ' [A-Z0-9]+$' ]]; then
    zle _expand_alias
    zle expand-word
  fi
  zle self-insert
}

zle -N globalias
bindkey " " globalias
# control-space to bypass completion
bindkey "^ " magic-space
# normal space during searches
bindkey -M isearch " " magic-space
alias -g G='|& grep -E -i'
alias -g L="| less"
alias -g X='| xargs'
alias -g X0='| xargs -0'
alias -g C='| wc -l'
alias -g A='| awk'
alias -g H='| head -n $(($LINES-5))'
alias -g T='| tail -n $(($LINES-5))'
alias -g S='| sed'
alias -g N='&> /dev/null'
alias -g XC='&> xclip -i -sel c'
# last modified(inode time) file or directory
alias -g NF="./*(oc[1])"

alias vi='$EDITOR'
alias vim='$EDITOR'
alias svi='sudo $EDITOR'
alias snano='sudo nano'

alias cd='z'

alias x='exit'
alias zreload='exec zsh'

alias hist='fc -l 1'

alias dud='du -s *(/)' # show directories size

alias rm='trash'

alias ll='ls -la' # Lists in one column, hidden files.
alias l='ls -l' # Lists in one column.

alias pgrep='pgrep -f'

alias pkill='pkill -9 -f'

alias port='netstat -ntlp tcp' # opening ports

alias pyshare='python3 -m http.server' # share current folder

alias cat='gcat'

alias head='ghead'

alias zcat='gzcat'

alias tailf='tail -f'

alias rm-relocated='rm $HOME/Desktop/Relocated\ Items.nosync && rm /Users/Shared/Relocated\ Items'

alias ypwd='pwd | pbcopy'

alias lsbundleid="osascript -e \
'on run args
set output to {}
repeat with param in args
set end of output to id of app param
end
set text item delimiters to linefeed
output as text
end'"

function lsgrep() {
  # about 'search through directory contents with grep'
  gls -l | grep -E -i "$*"

}

function quiet() {
  # about 'what *does* this do?'
  $* &>/dev/null &
}

function buf() {
  # about 'back up file with timestamp'
  # param 'filename'
  local filename=$1
  local filetime=$(date +%Y%m%d_%H%M%S)
  cp -a "${filename}" "${filename}_${filetime}"
}

function explain() {
  # about 'explain any bash command via mankier.com manpage API'
  # param '1: Name of the command to explain'
  # example '$ explain                # interactive mode. Type commands to explain in REPL'
  # example '$ explain '"'"'cmd -o | ...'"'"' # one quoted command to explain it.'
  if [ "$#" -eq 0 ]; then
    while read -p "Command: " cmd; do
      curl -Gs "https://www.mankier.com/api/explain/?cols="$(tput cols) --data-urlencode "q=$cmd"
    done
    echo "Bye!"
  elif [ "$#" -eq 1 ]; then
    curl -Gs "https://www.mankier.com/api/explain/?cols="$(tput cols) --data-urlencode "q=$1"
  else
    echo "Usage"
    echo "explain                  interactive mode."
    echo "explain 'cmd -o | ...'   one quoted command to explain it."
  fi
}

function sshlist() {
  # about 'list hosts defined in ssh config'
  awk '$1 ~ /Host$/ {for (i=2; i<=NF; i++) print $i}' ~/.ssh/config
}

function colours() {
  # about 'print colors'
  for i in {0..255}; do
    printf "\x1b[38;5;${i}mcolour${i}\n"
  done
}

function catt() {
  # about 'display whatever file is regular file or folder'
  # param '1: target file or dir'
  # example '$ catt ~/.zshrc'
  for i in "$@"; do
    if [ -d "$i" ]; then
      ll "$i"
    else
      cat "$i"
    fi
  done
}

function up() {
  # about 'update brew packages'
  brew update
  brew upgrade
  brew cleanup
  ls -l /usr/local/Homebrew/Library/Homebrew | grep homebrew-cask |
    awk '{print $9}' | for evil_symlink in $(cat -); do rm -v /usr/local/Homebrew/Library/Homebrew/$evil_symlink; done
  brew doctor
}

function up-cask() {
  # about update outdated casks
  OUTDATED=$(brew outdated --cask --greedy --verbose|sed -E '/latest/d'|awk '{print $1}' ORS=' '|tr -d '\n')
  # OUTDATED=$(brew outdated --cask --verbose|sed -E '/latest/d'|awk '{print $1}' ORS=' '|tr -d '\n')
  echo "outdated: $OUTDATED"
  [[ ! -z "$OUTDATED" ]] && brew reinstall --cask ${=OUTDATED}
}


# fzf
FZF_SHELL=/usr/local/opt/fzf/shell
# fzf auto-completion
[[ -f "$FZF_SHELL/completion.zsh" ]] &&  source "$FZF_SHELL/completion.zsh" 2> /dev/null
# fzf key bindings
[[ -f "$FZF_SHELL/key-bindings.zsh" ]] && source "$FZF_SHELL/key-bindings.zsh" 2>/dev/null


# display notification
alias ndone='open -g "hammerspoon://task-completed?message=Done"'
# say
alias lmk="say 'Process complete'"
# "Done" notification
alias -g D="; ndone"
# "Done" notification with sound
alias -g SD="; ndone; lmk"    


# ssh agent
if (( $+commands[ssh-agent] )); then
  # Set the path to the SSH directory.
  _ssh_dir="$HOME/.ssh"
  # Set the path to the environment file if not set by another module.
  _ssh_agent_env="${_ssh_agent_env:-${XDG_CACHE_HOME:-$HOME/.cache}/prezto/ssh-agent.env}"
  # Set the path to the persistent authentication socket.
  _ssh_agent_sock="${XDG_CACHE_HOME:-$HOME/.cache}/prezto/ssh-agent.sock"
  # Start ssh-agent if not started.
  if [[ ! -S "$SSH_AUTH_SOCK" ]]; then
    # Export environment variables.
    source "$_ssh_agent_env" 2> /dev/null
    # Start ssh-agent if not started.
    if ! ps -U "$LOGNAME" -o pid,ucomm | grep -q -- "${SSH_AGENT_PID:--1} ssh-agent"; then
      mkdir -p "$_ssh_agent_env:h"
      eval "$(ssh-agent | sed '/^echo /d' | tee "$_ssh_agent_env")"
    fi
  fi
  # Create a persistent SSH authentication socket.
  if [[ -S "$SSH_AUTH_SOCK" && "$SSH_AUTH_SOCK" != "$_ssh_agent_sock" ]]; then
    mkdir -p "$_ssh_agent_sock:h"
    ln -sf "$SSH_AUTH_SOCK" "$_ssh_agent_sock"
    export SSH_AUTH_SOCK="$_ssh_agent_sock"
  fi
  # Load identities.
  if ssh-add -l 2>&1 | grep -q 'The agent has no identities'; then
    zstyle -a ':prezto:module:ssh:load' identities '_ssh_identities'
    # ssh-add has strange requirements for running SSH_ASKPASS, so we duplicate
    # them here. Essentially, if the other requirements are met, we redirect stdin
    # from /dev/null in order to meet the final requirement.
    #
    # From ssh-add(1):
    # If ssh-add needs a passphrase, it will read the passphrase from the current
    # terminal if it was run from a terminal. If ssh-add does not have a terminal
    # associated with it but DISPLAY and SSH_ASKPASS are set, it will execute the
    # program specified by SSH_ASKPASS and open an X11 window to read the
    # passphrase.
    if [[ -n "$DISPLAY" && -x "$SSH_ASKPASS" ]]; then
      ssh-add ${_ssh_identities:+$_ssh_dir/${^_ssh_identities[@]}} < /dev/null 2> /dev/null
    else
      ssh-add ${_ssh_identities:+$_ssh_dir/${^_ssh_identities[@]}} 2> /dev/null
    fi
  fi
  # Clean up.
  unset _ssh_{dir,identities} _ssh_agent_{env,sock}
fi


# syntax highliting
source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh


# zsh autosuggestions
source /usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh || return 1
# set highlight color, default 'fg=8'.
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=8'
# key bindings
if [[ -n "$key_info" ]]; then
  # vi
  bindkey -M viins "$key_info[Control]F" vi-forward-word
  bindkey -M viins "$key_info[Control]E" vi-add-eol
fi


# zsh history substring search
source /usr/local/share/zsh-history-substring-search/zsh-history-substring-search.zsh
# key bindings
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down


# zoxide
export _ZO_DATA_DIR=$HOME/.local/share
eval "$(zoxide init zsh)"


# git
# aliases
# cat .gitconfig
alias cgc='cat ~/.gitconfig'
# open (in vim) all modified files in a git repository
alias gvm="git status --porcelain 2>/dev/null | sed -ne 's/^ M //p' | xargs vi"
# gl - git commit browser
unalias gl 2>/dev/null
gl() {
  git log --graph --color=always \
    --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
    fzf --ansi --no-sort --reverse --tiebreak=index --toggle-sort=\` \
      --bind "ctrl-m:execute:
                echo '{}' | grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R'"
}

if (( $+commands[fzf] )); then
  isGitRepo() {
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      return 0
    else
      return 1
    fi
  }
  fbx() {
    if ! isGitRepo; then
      echo "Not a git repository"
      return
    fi
    local branchList nBranch nBranchName oBranchName stashName swCmd
    branchList=$(git branch -a)
    oBranchName=$(echo "$branchList" | grep \* | sed 's/ *\* *//g')
    nBranch=$(echo "$branchList" | fzf-tmux -d30 -- -x --select-1 --exit-0 | sed 's/ *//')
    zle reset-prompt
    [[ -n "${nBranch}" ]] || return
    if [[ $nBranch =~ 'origin' ]]; then
      nBranchName=$(echo "$nBranch" | sed "s/.*origin\///")
      swCmd="git checkout -b $nBranchName $nBranch"
    else
      nBranchName=$(echo "$nBranch" | sed "s/.* //")
      swCmd="git checkout $nBranchName"
    fi
    [[ $nBranchName != $oBranchName ]] || return
    stashName=$(git stash list | grep -m 1 "On ${oBranchName}: ==${oBranchName}" | sed -E "s/(stash@\{.*\}): .*/\1/g")
    [[ -n "${stashName}" ]] && git stash drop "$stashName"
    git stash save "==$oBranchName" 2>/dev/null
    eval $swCmd
    stashName=$(git stash list | grep -m 1 "On ${nBranchName}: ==${nBranchName}" | sed -E "s/(stash@\{.*\}): .*/\1/g")
    [[ -n "${stashName}" ]] && git stash apply "${stashName}"
    zle reset-prompt
  }
  zle -N fbx
  bindkey '^x^b' fbx # checkout git branch + stash/unstash named changes (ctrl+x,ctrl+b)
  fb() {
    if ! isGitRepo; then
      echo "Not a git repository"
      return
    fi
    local branches branch
    branches=$(git branch -a)
    branch=$(echo "$branches" | fzf-tmux -d30 -- -x --query="$*" --select-1 --exit-0 | sed 's/ *//')
    if [[ $branch =~ 'origin' ]]; then
      git checkout -b $(echo "$branch" | sed "s/.*origin\///") $branch
    else
      git checkout $(echo "$branch" | sed "s/.* //")
    fi
    zle reset-prompt
  }
  zle -N fb
  bindkey '^x^g' fb # checkout git branch (ctrl+x,ctrl+g)
fi


# dump brew packages
alias bbd='brew bundle dump --all --force --file=$HOME/z.dots/brew/Brewfile'


# add sudo before command with esc+esc
function prepend-sudo() {
  [[ -z $BUFFER ]] && zle up-history
  if [[ $BUFFER == sudo\ * ]]; then
    LBUFFER="${LBUFFER#sudo }"
  else
    LBUFFER="sudo $LBUFFER"
  fi
}
zle -N prepend-sudo
# defined shortcut keys: [Esc] [Esc]
bindkey "\e\e" prepend-sudo


# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
P10K_THEME=$(brew --prefix)/opt/powerlevel10k/powerlevel10k.zsh-theme
[[ -f $P10K_THEME ]] && source "$P10K_THEME"
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
